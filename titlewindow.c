/* Plugin structure generated by Schiavoni Pure Data external Generator */
#include "m_pd.h"
#include "g_canvas.h"
#include "g_all_guis.h"
#include <string.h>
#include <time.h>
#include <stdlib.h>
#include <stdio.h>

static t_class *titlewindow_class;

typedef struct _titlewindow {
   t_object x_obj;
   t_symbol *sp_name;
   t_symbol *sp_title;
   t_glist *glist;
   t_canvas *x_canvas;
} t_titlewindow;

t_glist * titlewindow_find_parent(t_glist * glist);
void titlewindow_recursive_search(t_titlewindow *x, t_glist *c, t_symbol *sp_name);
void titlewindow_do(t_titlewindow *x, t_canvas * c);

void titlewindow_process(t_titlewindow *x){
  t_glist *c = x->x_canvas;
   if(c == NULL){
      return;
   }

   if(strcmp(x->sp_name->s_name, "") == 0){
      titlewindow_do(x, (t_canvas*) x->x_canvas);
      return;
   }
   titlewindow_recursive_search(x, c, x->sp_name);
}

void titlewindow_title(t_titlewindow *x, t_symbol * title){
   x->sp_title = title;
   titlewindow_process(x);
}


void titlewindow_set(t_titlewindow *x, t_symbol * sp_name){
   x->sp_name = sp_name;
   if(strcmp(sp_name->s_name, "") == 0){
      t_canvas *canvas=(t_canvas*)glist_getcanvas(x->glist);
      x->x_canvas = canvas;
      return;
   }
   //It was empty. Now we need to find the parent
   if(strcmp(x->sp_name->s_name, "") != 0){
      t_glist * glist = titlewindow_find_parent(x->x_canvas);
      t_canvas *canvas=(t_canvas*)glist_getcanvas(glist);
      x->x_canvas = canvas;
   }
}

void titlewindow_do(t_titlewindow *x, t_canvas * c){
   if(x->sp_title != NULL)
      sys_vgui("wm title .x%lx \"%s\";\n", c, x->sp_title->s_name);
}



void titlewindow_recursive_search(t_titlewindow *x, t_glist *c, t_symbol *sp_name){
   t_gobj*obj = NULL;
   for(obj = c->gl_list; obj; obj = obj->g_next) {
      if(pd_class(&obj->g_pd) != canvas_class)
         continue;
      //if subpatchname is empty, don't go recursively
      titlewindow_recursive_search(x, ((t_glist *)obj) ,sp_name);
      //look for subpatch name
      t_binbuf *bz = binbuf_new();
      t_symbol *patchsym;
      binbuf_addbinbuf(bz, ((t_canvas *)obj)->gl_obj.ob_binbuf);
      patchsym = atom_getsymbolarg(1, binbuf_getnatom(bz), binbuf_getvec(bz));
      binbuf_free(bz);
      if(strcmp(sp_name->s_name, patchsym->s_name) == 0
         || strcmp(sp_name->s_name, "") == 0)
         titlewindow_do(x, (t_canvas *)obj);
   }
}

t_glist * titlewindow_find_parent(t_glist * glist){
   while(glist->gl_owner){
      glist = glist->gl_owner;
   }
   return glist;
}

// Constructor of the class
void * titlewindow_new(t_symbol *sp_name_arg) {
   t_titlewindow *x = (t_titlewindow *) pd_new(titlewindow_class);
   t_glist *glist=(t_glist *)canvas_getcurrent();
   x->glist = glist;
   x->sp_name = sp_name_arg;
   // if no name, we use the actual canvas
   if(strcmp(x->sp_name->s_name, "") != 0)
      glist = titlewindow_find_parent(glist);
   t_canvas *canvas=(t_canvas*)glist_getcanvas(glist);
   x->x_canvas = canvas;
   x->sp_title = NULL;
   return (void *) x;
}

// Destroy the class
void titlewindow_destroy(t_titlewindow *x) {
   (void) x;
//   post("You say good bye and I say hello");
}


void titlewindow_setup(void) {
   titlewindow_class = class_new(gensym("titlewindow"),
      (t_newmethod) titlewindow_new, // Constructor
      (t_method) titlewindow_destroy, // Destructor
      sizeof (t_titlewindow),
      CLASS_DEFAULT,
      A_DEFSYMBOL,
      0);//Must always ends with a zero

   class_addmethod(titlewindow_class, (t_method) titlewindow_title, gensym("title"),A_DEFSYMBOL,  0);
   class_addmethod(titlewindow_class, (t_method) titlewindow_set, gensym("set"),A_DEFSYMBOL,  0);
}
